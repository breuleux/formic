
require:
    lib
    common
    highlight

cr = "\n"[0]

Source = [text, url = false] ->

    lines = V enumerate[chain[text, "\n"[0] :: nil]] each [i, c] ->
        if (c == cr):
            i
        else:
            (false, continue)

    self =
        [r] -> text[r]
        .text -> text
        .url -> url
        .nlines -> lines.length
        .linecol -> [pos] ->
            if (pos < 0 or pos > text.length):
                raise #outofbounds[pos, self]
            current = -1
            do enumerate[lines, 1] each [i, n] ->
                if (pos == n):
                    break [i + 1, 0]
                elif (pos < n):
                    break [i, pos - current]
                current := n
        r when (r == repr) ->
            #struct[repr[.Source], repr[url]]

        .highlight_lines -> [Range lrange, spans = nil, => raw = false] ->
            hl = highlight_lines[text, lines, lrange, spans]
            if[raw, hl, Repr[hl]]

    self


Location =
  context = dyn[0]

  .context -> context
  [source, Range [start, end]] ->

    self =
        .source -> source
        .start -> start
        .end -> end

        .range -> start..end
        .text -> source[start..end]

        .linecol ->
            incl_end = end - 1
            [l1, c1] = source.linecol[start]
            if (start > incl_end):
                [[l1, c1], false]
            else:
                [[l1, c1], source.linecol[incl_end]]

        .linerange ->
            source.linecol[start][0] .. (source.linecol[end][1] + 1)

        .ref ->
            match self.linecol:
                [[l1, c1], false _] ->
                    (++)[String[l1], ":", String[c1]]
                [[l1, c1], [l2, c2]] ->
                    if (l1 == l2 and c1 == c2):
                        (++)[String[l1], ":", String[c1]]
                    elif (l1 == l2):
                        (++)[String[l1], ":", String[c1], "-", String[c2]]
                    else:
                        (++)[String[l1], ":", String[c1], "-", String[l2], ":", String[c2]]

        .at_start -> Location[source, start .. start]
        .at_end -> Location[source, end .. end]

        .highlight -> [cls = "hl1", => context = 0] ->
            highlight_locations[self => cls, context = context]

        #dispatch[0, x] when (x == (+)) -> [loc2] ->
            merge_locations[self, loc2]

        x when (x == repr) ->
            highlight_locations[self => "hl1", context = @context, raw = true]

    self


merge_locations = Vector locations ->
    if (locations.length == 0):
        Location[false, 0..0]
    else:
        start = min locations each loc -> loc.start
        end = max locations each loc -> loc.end
        Location[locations[0].source, start..end]


highlight_locations = [=> context = 0, => raw = false, **locations] ->
    loc = merge_locations(V locations each Pair [loc, cls] -> loc)
    source = loc.source
    Range [line1, line2] = loc.linerange
    first = max[1, line1 - context]
    last = min[source.nlines, line2 + context] + 1
    source.highlight_lines[
        first .. last
        locations each Pair [loc, cls] -> [loc.range, [cls]]
        raw = raw
    ]


provide:
    Source
    Location
    merge_locations

