
require:
    lib
    common
    highlight

cr = "\n"[0]

Source = [text, url = false] ->

    lines = V enumerate[chain[text, "\n"[0] :: nil]] each [i, c] ->
        if (c == cr):
            i
        else:
            (false, continue)

    self =
        [r] -> text[r]
        .text -> text
        .url -> url
        .nlines -> lines.length
        .linecol -> [pos] ->
            if (pos < 0 or pos > text.length):
                raise #outofbounds[pos, self]
            current = -1
            do enumerate[lines, 1] each [i, n] ->
                if (pos == n):
                    break [i + 1, 0]
                elif (pos < n):
                    break [i, pos - current]
                current := n
        r when (r == repr) ->
            #struct[repr[.Source], repr[url]]

        .highlight_lines -> [Range lrange, spans = nil] ->
            Repr[highlight_lines[text, lines, lrange, spans]]

    self


Location = [source, Range [start, end]] ->

    self =
        .source -> source
        .start -> start
        .end -> end

        .range -> start..end
        .text -> source[start..end]

        .linecol ->
            incl_end = end - 1
            [l1, c1] = source.linecol[start]
            if (start > incl_end):
                [[l1, c1], false]
            else:
                [[l1, c1], source.linecol[incl_end]]

        .linerange ->
            source.linecol[start][0] .. (source.linecol[end][1] + 1)

        .ref ->
            match self.linecol:
                [[l1, c1], false _] ->
                    (++)[String[l1], ":", String[c1]]
                [[l1, c1], [l2, c2]] ->
                    if (l1 == l2 and c1 == c2):
                        (++)[String[l1], ":", String[c1]]
                    elif (l1 == l2):
                        (++)[String[l1], ":", String[c1], "-", String[c2]]
                    else:
                        (++)[String[l1], ":", String[c1], "-", String[l2], ":", String[c2]]

        .at_start -> Location[source, start .. start]
        .at_end -> Location[source, end .. end]

        .highlight -> [cls = "hl1", => context = 0] ->
            highlight_locations[self => cls, context = context]

        #dispatch[0, x] when (x == (+)) -> [loc2] ->
            merge_locations[self, loc2]

    self


merge_locations = Vector locations ->
    if (locations.length == 0):
        Location[false, 0..0]
    else:
        start = min locations each loc -> loc.start
        end = max locations each loc -> loc.end
        Location[locations[0].source, start..end]


highlight_locations = [=> context = 0, **locations] ->
    loc = merge_locations(V locations each Pair [loc, cls] -> loc)
    source = loc.source
    Range [line1, line2] = loc.linerange
    first = max[1, line1 - context]
    last = min[source.nlines, line2 + context] + 1
    source.highlight_lines[
        first .. last
        locations each Pair [loc, cls] -> [loc.range, [cls]]
    ]


s = Source["one\ntwo\nthree\nfour\nfive\nsix"]

<> s
<> s.text
<> s.highlight_lines[3..6]



loc1 = Location[s, 1..3]
loc2 = Location[s, 8..17]


<> loc1.ref
<> loc2.ref
<> (loc1 + loc2).ref

<> highlight_locations[loc2 => "hl2", context = 1]
<> loc1.highlight["hl3"]
